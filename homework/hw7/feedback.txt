Git commit: caaba6d2eb9b733271059c2f11ebff421412024a

valgrind results, leaks present:

==22983== Memcheck, a memory error detector
==22983== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.
==22983== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info
==22983== Command: ./trie_test
==22983== Parent PID: 22197
==22983== 
==22983== 
==22983== HEAP SUMMARY:
==22983==     in use at exit: 1,546,608 bytes in 32,221 blocks
==22983==   total heap usage: 2,719,226 allocs, 2,687,005 frees, 132,312,801 bytes allocated
==22983== 
==22983== LEAK SUMMARY:
==22983==    definitely lost: 476,208 bytes in 9,921 blocks
==22983==    indirectly lost: 1,070,400 bytes in 22,300 blocks
==22983==      possibly lost: 0 bytes in 0 blocks
==22983==    still reachable: 0 bytes in 0 blocks
==22983==         suppressed: 0 bytes in 0 blocks
==22983== Rerun with --leak-check=full to see details of leaked memory
==22983== 
==22983== For counts of detected and suppressed errors, rerun with: -v
==22983== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)


unit test results, 7/9 tests pass:

     CUnit - A unit testing framework for C - Version 2.1-3
     http://cunit.sourceforge.net/


Suite: trie
  Test: create_destroy ...passed
  Test: trie_set_get ...passed
  Test: trie_insert ...passed
  Test: trie_find ...passed
  Test: trie_size ...passed
  Test: trie_insert_random ...passed
  Test: trie_walk ...FAILED
    1. trie_test.c:248  - CU_ASSERT_EQUAL(hash,expected)
    2. trie_test.c:252  - CU_ASSERT_FALSE(trie_walk(t, test_walk_walker2, &countdown))
    3. trie_test.c:253  - CU_ASSERT_EQUAL(countdown,0)
  Test: trie_remove_fixed ...passed
  Test: trie_remove ...FAILED
    
Run Summary:    Type  Total    Ran Passed Failed Inactive
              suites      1      1    n/a      0        0
               tests      9      9      7      2        0
             asserts  50143  50143  42555   7588      n/a

Elapsed time =    0.786 seconds

Good comments in more involved functions. I like the idea of usage of goto to break out of several nested loops. However, with --show-reachable=yes and --leak-check=full options on, I can see a large amount of the memory leaks coming from unfreed pointers in trie_insert
